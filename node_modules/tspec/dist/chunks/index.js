import express from 'express';
import { createProxyMiddleware } from 'http-proxy-middleware';
import swaggerUI from 'swagger-ui-express';
import fs from 'fs/promises';
import path, { dirname } from 'path';
import debug from 'debug';
import glob from 'glob';
import ts from 'typescript';
import * as TJS from 'typescript-json-schema';
import convert from 'json-schema-to-openapi-schema';

function isDefined(val) {
  return val !== undefined && val !== null;
}

function assertIsDefined(
  val,
  msg,
) {
  if (!isDefined(val)) {
    throw new Error(
      `Expected 'val' to be defined, but received: ${val};${msg || ''}`,
    );
  }
}

function _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }



const accessSchema = (
  obj,
  schemas,
) => {
  if (!obj) {
    return undefined;
  }
  if ('$ref' in obj) {
    const [, schemaName] = obj.$ref.split('#/components/schemas/');
    return schemas[schemaName];
  }
  return obj;
};

const accessProperty = (
  obj,
  key,
  schemas,
) => {
  const schema = accessSchema(obj, schemas);
  if (!schema) {
    return undefined;
  }
  const combinedSchema = schema.allOf || schema.oneOf || schema.anyOf;
  if (combinedSchema) {
    return combinedSchema.map((o) => accessProperty(o, key, schemas)).find((o) => o);
  }
  const value = _optionalChain$3([schema, 'access', _ => _.properties, 'optionalAccess', _2 => _2[key]]);
  return value && accessSchema(value, schemas);
};

const getPropertyByPath = (
  obj,
  path,
  schemas,
) => {
  const [first, ...rest] = path.split('.');
  const firstValue = accessProperty(obj, first, schemas);
  if (rest.length === 0) {
    return firstValue;
  }
  return getPropertyByPath(firstValue, rest.join('.'), schemas);
};

const getText = (obj) => {
  if (!obj || '$ref' in obj || obj.type !== 'string' || _optionalChain$3([obj, 'access', _3 => _3.enum, 'optionalAccess', _4 => _4.length]) !== 1) {
    return undefined;
  }
  return obj.enum[0];
};

const getTextPropertyByPath = (
  obj, path, schemas, options,
) => {
  const text = getText(getPropertyByPath(obj, path, schemas));
  if (_optionalChain$3([options, 'optionalAccess', _5 => _5.required]) === true && !text) {
    throw new Error(`Invalid '${path}' in ApiSpec`);
  }
  return text ;
};

const getTextListPropertyByPath = (
  obj,
  path,
  schemas,
  options,
) => {
  const value = getPropertyByPath(obj, path, schemas);
  if (!value || '$ref' in value || value.type !== 'array' || !value.items) {
    if (_optionalChain$3([options, 'optionalAccess', _6 => _6.required]) === true) {
      throw new Error(`Invalid '${path}' in ApiSpec`);
    }
    return [];
  }
  return (value.items )
    .map((item) => getText(item)).filter((item) => !!item);
};

const getObjectPropertyByPath = (
  obj, path, schemas, options,
) => {
  const value = getPropertyByPath(obj, path, schemas);
  if (!value || '$ref' in value || value.type !== 'object' || !value.properties) {
    if (_optionalChain$3([options, 'optionalAccess', _7 => _7.required]) === true) {
      throw new Error(
        `Invalid '${path}' in ${JSON.stringify(obj)}; value: ${JSON.stringify(value)}`,
      );
    }
    return undefined;
  }
  return { ...value, properties: value.properties };
};

function _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

const DEBUG$1 = debug('tspec');









const parseBooleanAnnotation = (value) => {
  if (value === undefined) {
    return undefined;
  }
  if (value === '' || value === 'true' || value === true) {
    return true;
  }
  return false;
};

const getParameters = (obj, inType) => {
  const { properties, required } = obj;
  if (!properties) {
    return undefined;
  }
  return Object.entries(properties).map(([key, schema]) => {
    const {
      description, style, explode, allowReserved, allowEmptyValue,...rest
    } = schema ;
    return {
      description,
      name: key,
      in: inType,
      required: inType === 'path' ? true : (required || []).includes(key),
      schema: rest,
      style,
      explode: parseBooleanAnnotation(explode),
      allowReserved: parseBooleanAnnotation(allowReserved), 
      allowEmptyValue: parseBooleanAnnotation(allowEmptyValue),
    };
  });
};

const resolveParameters = ({ path, query, header, cookie }) => {
  const pathParams = (path && getParameters(path, 'path')) || [];
  const queryParams = (query && getParameters(query, 'query')) || [];
  const headerParams = (header && getParameters(header, 'header')) || [];
  const cookieParams = (cookie && getParameters(cookie, 'cookie')) || [];
  return [...pathParams, ...queryParams, ...headerParams, ...cookieParams];
};

const omitPathSchemaFields = (schema) => {
  const { mediaType, ...rest } = schema;
  return rest;
};

const isNoContentSchema = (schema) => (
  'type' in schema && schema.type === 'string'
  && 'enum' in schema && Array.isArray(schema.enum)
  && schema.enum.length === 1 && schema.enum[0] === ''
);


const getOpenapiPaths = (
  openapiSchemas,
  tspecSymbols,
) => {
  const openapiPaths = {};

  const specs = tspecSymbols.flatMap((tspecSymbol) => {
    const paths = openapiSchemas[tspecSymbol].properties || {};
    return Object.keys(paths).flatMap((path) => {
      const methods = _optionalChain$2([accessSchema, 'call', _ => _(paths[path], openapiSchemas), 'optionalAccess', _2 => _2.properties]) || {};
      return Object.keys(methods).map((method) => {
        const spec = accessSchema(methods[method], openapiSchemas);
        assertIsDefined(spec);
        return {
          controllerName: tspecSymbol, path, method, spec,
        };
      });
    });
  });

  specs.forEach(({
    controllerName, path, method, spec,
  }) => {
    DEBUG$1({ controllerName, path, method });
    DEBUG$1({ spec: JSON.stringify(spec, null, 2) });
    const url = getTextPropertyByPath(spec, 'url', openapiSchemas, { required: true });
    const operationId = getTextPropertyByPath(spec, 'operationId', openapiSchemas);
    const summary = getTextPropertyByPath(spec, 'summary', openapiSchemas);
    const description = getTextPropertyByPath(spec, 'description', openapiSchemas);
    const security = getTextPropertyByPath(spec, 'security', openapiSchemas);
    const tags = getTextListPropertyByPath(spec, 'tags', openapiSchemas);
    const responses = getObjectPropertyByPath(
      spec,
      'responses',
      openapiSchemas,
    ) || { properties: {} };

    const pathParams = getObjectPropertyByPath(spec, 'path', openapiSchemas) ;
    const queryParams = getObjectPropertyByPath(spec, 'query', openapiSchemas) ;
    const headerParams = getObjectPropertyByPath(spec, 'header', openapiSchemas) ;
    const cookieParams = getObjectPropertyByPath(spec, 'cookie', openapiSchemas) ;
    const bodyParams = getObjectPropertyByPath(spec, 'body', openapiSchemas) ;

    const operation = {
      operationId: operationId || `${controllerName}_${method}_${path}`,
      tags,
      summary,
      description,
      security: security && [{ [security]: [] }],
      parameters: resolveParameters({
        path: pathParams,
        query: queryParams,
        header: headerParams,
        cookie: cookieParams,
      }),
      requestBody: bodyParams && {
        description: bodyParams.description,
        required: true,
        content: {
          [_optionalChain$2([bodyParams, 'optionalAccess', _3 => _3.mediaType]) || 'application/json']: {
            schema: omitPathSchemaFields(bodyParams),
          },
        },
      },
      responses: Object.fromEntries(
        Object.keys(responses.properties).map((code) => {
          const schema = getPropertyByPath(responses, code, openapiSchemas);
          const { description = '', mediaType } = schema ;
          const contentSchema = responses.properties[code];
          const isNoContent = isNoContentSchema(contentSchema);
          const resSchema = {
            description,
            content: isNoContent ? undefined : {
              [mediaType || 'application/json']: {
                schema: contentSchema,
              },
            },
          };
          return [code, resSchema];
        }),
      ),
    };
    (openapiPaths[url] ||= {})[method ] = operation ;
  });

  return openapiPaths;
};

const isSchemaNullableOnly = (s) => (
  Object.keys(s).filter((key) => s[key] !== undefined).length === 1 && s.nullable
);

const convertCombinedNullableInner = (schema, field) => {
  const types = schema[field] || [];
  const nullable = types.some((s) => isSchemaNullableOnly(s)) || undefined;
  return {
    ...schema,
    [field]: types.filter((s) => !isSchemaNullableOnly(s)),
    nullable,
  };
};

/** NOTE(hyeonseong): when anyOf or oneOf contains null, it should be nullable. */
const handleCombinedNullable = (schema) => { // TODO: fix types
  if (schema.anyOf) {
    return convertCombinedNullableInner(schema, 'anyOf');
  }
  if (schema.oneOf) {
    return convertCombinedNullableInner(schema, 'oneOf');
  }
  return schema;
};

const convertToNullableSchema = (schema) => {
  if (schema.type && !Array.isArray(schema.type) && schema.type === 'null') {
    return {
      ...schema,
      type: undefined,
      nullable: true,
    };
  }
  if (schema.type && Array.isArray(schema.type) && schema.type.length > 1) {
    const nullable = schema.type.includes('null');
    const types = schema.type.filter((type) => type !== 'null');
    if (types.length === 1) {
      return {
        ...schema,
        type: types[0],
        nullable,
      };
    }
    return {
      ...schema,
      type: undefined,
      oneOf: schema.type
        .filter((type) => type !== 'null')
        .map((type) => ({ ...schema, type })),
      nullable,
    };
  }
  return schema;
};

const handleExamples = (schema) => { // TODO: fix types
  if (schema.examples) {
    const { examples, ...rest } = schema;
    return {
      ...rest,
      example: Array.isArray(examples) ? examples[0] : examples,
    };
  }
  return schema;
};

const handleDeprecated = (schema) => { // TODO: fix types
  if (schema.deprecated !== undefined && schema.deprecated !== false) {
    const { deprecated, ...rest } = schema;
    return {
      ...rest,
      deprecated: true,
    };
  }
  return schema;
};

const convertToOpenapiTypes = (schema) => { // TODO: fix types
  if (Array.isArray(schema)) {
    return schema.map((s) => convertToOpenapiTypes(s));
  }
  if (schema && typeof schema === 'object') {
    const nullableSchema = convertToNullableSchema(schema);
    const convertedSchema = Object.fromEntries(
      Object.entries(nullableSchema).map(([key, value]) => [key, convertToOpenapiTypes(value)]),
    );
    const handlers = [handleCombinedNullable, handleExamples, handleDeprecated];
    return handlers.reduce((acc, handler) => handler(acc), convertedSchema);
  }
  return schema;
};

const findAllRefAndReplace = (schema, nameMapping) => { // TODO: fix types
  if (Array.isArray(schema)) {
    return schema.map((s) => findAllRefAndReplace(s, nameMapping));
  }
  if (schema && typeof schema === 'object') {
    if (schema.$ref) {
      const [, schemaName] = schema.$ref.split('#/definitions/');
      return {
        ...schema,
        $ref: `#/components/schemas/${nameMapping[schemaName]}`,
      };
    }
    return Object.fromEntries(
      Object.entries(schema).map(([key, value]) => [key, findAllRefAndReplace(value, nameMapping)]),
    );
  }
  return schema;
};

const escapeSchemaNames = (schemas) => {
  const escapedNameMapping = Object.fromEntries(Object.keys(schemas).map((schemaName) => (
    // only contain the characters A-Z a-z 0-9 - . _
    [schemaName, schemaName.replace(/[^A-Za-z0-9_.-]/g, '_')]
  )));
  const escapedSchemas = Object.fromEntries(Object.entries(schemas).map(([schemaName, schema]) => (
    [escapedNameMapping[schemaName], schema]
  )));
  // eslint-disable-next-line max-len
  return findAllRefAndReplace(escapedSchemas, escapedNameMapping) ; // TODO: fix types
};

const convertToOpenapiSchemas = async (
  jsonSchemas,
) => {
  const convertedJsonSchemas = convertToOpenapiTypes(jsonSchemas);
  const openapiSchemas = await convert(convertedJsonSchemas) ;
  return escapeSchemaNames(openapiSchemas);
};

function _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const readTspecConfig = (path) => {
  try {
    return fs.readFile(path, { encoding: 'utf8' });
  } catch (err) {
    console.error('Cannot read Tspec config');
    throw err;
  }
};

const parseTspecConfig = (config) => {
  try {
    return JSON.parse(config);
  } catch (err) {
    console.error('Cannot parse Tspec config');
    throw err;
  }
};












function validateTspecConfig(config) {
  const errors = [];

  const validatePrimitive = (property, value, type) => {
    assertIsDefined(type);
    if (typeof value !== type) { // eslint-disable-line valid-typeof
      errors.push({
        message: `property is not a ${type}.`,
        property,
      });
    }
  };

  const validateStringArray = (property, value) => {
    if (!Array.isArray(value)) {
      errors.push({
        message: 'property is not an array.',
        property,
      });
    } else if (value.some((glob) => typeof glob !== 'string')) {
      errors.push({
        message: 'property contains more than one non-string value.',
        property,
      });
    }
  };

  if (config.specPathGlobs) {
    validateStringArray('specPathGlobs', config.specPathGlobs);
  }
  if (config.tsconfigPath) {
    validatePrimitive('tsconfigPath', config.tsconfigPath, 'string');
  }
  if (config.outputPath) {
    validatePrimitive('outputPath', config.outputPath, 'string');
  }
  if (_optionalChain$1([config, 'access', _ => _.openapi, 'optionalAccess', _2 => _2.title])) {
    validatePrimitive('openapiTitle', config.openapi.title, 'string');
  }
  if (_optionalChain$1([config, 'access', _3 => _3.openapi, 'optionalAccess', _4 => _4.version])) {
    validatePrimitive('openapiVersion', config.openapi.version, 'string');
  }
  if (_optionalChain$1([config, 'access', _5 => _5.openapi, 'optionalAccess', _6 => _6.description])){
    validatePrimitive('openapiDescription', config.openapi.description, 'string');
  }
  if (config.debug) {
    validatePrimitive('debug', config.debug, 'boolean');
  }
  if (config.ignoreErrors) {
    validatePrimitive('ignoreErrors', config.ignoreErrors, 'boolean');
  }

  if (errors.length) {
    const message = `Tspec configuration file is not valid.\n${
      errors.map((error) => `${error.property}: ${error.message}`).join('\n')
    }\n`;
    throw new Error(message);
  }
}

const getConfigPath = (inputPath) => {
  const filePath = inputPath;
  return path.join(process.cwd(), filePath);
};

const isTspecFileConfigAvailable = async (inputPath) => {
  const configPath = getConfigPath(inputPath);
  return fs.access(configPath)
    .then(() => true)
    .catch(() => false);
};

const getTspecConfigFromConfigFile = async (
  inputPath,
) => {
  const configPath = getConfigPath(inputPath);
  const fileResult = await readTspecConfig(configPath);

  const config = parseTspecConfig(fileResult);
  validateTspecConfig(config);

  return config;
};

const isObject = (item) => (
  item && typeof item === 'object' && !Array.isArray(item)
);

const mergeDeep = (target, source) => {
  let output = { ...target } ;
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(key => {
      const value = source[key];
      if (value === undefined) {
        return;
      }
      if (isObject(value)) {
        if (!(key in target)) {
          Object.assign(output, { [key]: value });
        } else {
          output[key ] = mergeDeep(target[key], value);
        }
      } else {
        Object.assign(output, { [key]: value });
      }
    });
  }
  return output;
};

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const DEBUG = debug('tspec');

const isNodeExported = (node) => (
  // eslint-disable-next-line no-bitwise
  (ts.getCombinedModifierFlags(node ) & ts.ModifierFlags.Export) !== 0
  || (!!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile)
);

const getTspecSignatures = (p) => {
  const entryPoints = p
    .getRootFileNames()
    .map((entryPointName) => p.getSourceFile(entryPointName)).filter(isDefined);

  const names = [];
  entryPoints.forEach((srcFile) => {
    srcFile.forEachChild((node) => {
      if (!isNodeExported(node)) {
        return;
      }

      // NOTE(hyeonseong): typescript 5.0 changed node kind of type alias declaration.
      // if (
      //   !ts.isTypeAliasDeclaration(node)
      //   || !ts.isTypeReferenceNode(node.type)
      // ) {
      //   return;
      // }

      if (_optionalChain([(node ), 'access', _ => _.type, 'optionalAccess', _2 => _2.typeName, 'optionalAccess', _3 => _3.right, 'optionalAccess', _4 => _4.escapedText]) !== 'DefineApiSpec') {
        return;
      }
      const name = (node ).name.escapedText ;
      if (names.includes(name)) {
        throw new Error(`Duplicate name: ${name}`);
      }
      names.push(name);
    });
  });

  return names;
};

const getCompilerOptions = (tsconfigPath) => {
  const { config, error } = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
  if (error) {
    throw new Error(error.messageText );
  }
  return {
    ...config.compilerOptions,
    noEmit: true,
  };
};

const getDefaultProgramFiles = (compilerOptions) => {
  const { rootDir, rootDirs } = compilerOptions;
  const globs = [rootDir, ...(rootDirs || [])].filter(isDefined)
    .flatMap((r) => [`${r}/*.ts`, `${r}/**/*.ts`]);
  if (globs.length === 0) {
    return ['**/*.ts'];
  }
  return globs;
};

const getProgramFiles = (compilerOptions, specPathGlobs) => {
  const srcGlobs = specPathGlobs || getDefaultProgramFiles(compilerOptions);
  const programFils = [...new Set(srcGlobs.flatMap((g) => glob.sync(g, {
    ignore: ['**/node_modules/**'],
  })))];
  DEBUG({ programFils });
  return programFils;
};

/**
 * 제대로 동작하지 않는 케이스..?
 * 1. Partial of Record
 * export type BlockRegions = Partial<Record<'es' | 'en', { blockAt: string }>>;
 */
const getOpenapiSchemas = async (
  tsconfigPath,
  specPathGlobs,
  ignoreErrors,
) => {
  const compilerOptions = getCompilerOptions(tsconfigPath);
  DEBUG({ compilerOptions });
  const files = getProgramFiles(compilerOptions, specPathGlobs);
  DEBUG({ files });
  const program = TJS.getProgramFromFiles(files, compilerOptions);

  const tjsSettings = {
    required: true,
    noExtraProps: true,
    strictNullChecks: true,
    ignoreErrors: ignoreErrors || true,
    esModuleInterop: compilerOptions.esModuleInterop,
    constAsEnum: true,
    // rejectDateType: true,
    validationKeywords: [
      /** NOTE: JSON schema keywords. see https://swagger.io/docs/specification/data-models/keywords/ */
      'title', 'pattern',
      'minimum', 'maximum', 'exclusiveMinimum', 'exclusiveMaximum', 'multipleOf',
      'minLength', 'maxLength', 'pattern',
      'minItems', 'maxItems', 'uniqueItems',
      'minProperties', 'maxProperties',
      /** NOTE: These keywords are supported with minor differences */
      /** 'type', */ 'format', 'description', 'default',
      /** NOTE: Additional keywords */
      'deprecated', 'discriminator', 'example', 'externalDocs', 'nullable', /** 'readOnly', 'writeOnly', */
      /** NOTE: parameter validation. see https://swagger.io/docs/specification/describing-parameters/ */
      'allowReserved', 'style', 'form', 'allowEmptyValue', 'explode',
      /** NOTE: media type. see https://swagger.io/docs/specification/media-types/ */
      'mediaType',
    ],
  };
  DEBUG({ tjsSettings });
  const generator = TJS.buildGenerator(program, tjsSettings);
  assertIsDefined(generator);

  const tspecSymbols = getTspecSignatures(program );
  DEBUG({ tspecSymbols });
  const { definitions: jsonSchemas } = generator.getSchemaForSymbols(tspecSymbols);
  assertIsDefined(jsonSchemas);
  DEBUG({ schemaKeys: Object.keys(jsonSchemas) });

  const openapiSchemas = await convertToOpenapiSchemas(jsonSchemas);

  return { openapiSchemas, tspecSymbols };
};

const getOpenapiSchemasOnly = (openapiSchemas, tspecSymbols) => {
  const tspecPathSchemas = tspecSymbols.flatMap((tspecSymbol) => {
    const paths = openapiSchemas[tspecSymbol].properties || {};
    DEBUG({ tspecSymbol, paths });
    return Object.keys(paths).map((path) => {
      const obj = paths[path];
      if ('$ref' in obj) {
        const [, schemaName] = obj.$ref.split('#/components/schemas/');
        return schemaName;
      }
      return undefined;
    });
  });

  const isTspecSchema = (key) => (
    tspecSymbols.includes(key) || tspecPathSchemas.includes(key)
  );

  const omitPathSchemaFields = (schema) => {
    const { mediaType, ...rest } = schema;
    return rest;
  };

  return Object.fromEntries(
    Object.entries(openapiSchemas)
      .filter(([key]) => !isTspecSchema(key))
      .map(([key, value]) => [key, omitPathSchemaFields(value)]),
  );
};

const defaultGenerateParams = {
  specPathGlobs: ['**/*.ts'],
  tsconfigPath: 'tsconfig.json',
  configPath: 'tspec.config.json',
  specVersion: 3,
  openapi: {
    title: 'Tspec API',
    version: '0.0.1',
    description: '',
  },
  debug: false,
  ignoreErrors: true,
} ;

const getGenerateTspecParams = async (
  overrideParams = {},
) => {
  const configPath = overrideParams.configPath || defaultGenerateParams.configPath;

  if (await isTspecFileConfigAvailable(configPath)) {
    const fileConfig = await getTspecConfigFromConfigFile(configPath);
    return mergeDeep(mergeDeep(defaultGenerateParams, fileConfig), overrideParams);
  }

  return mergeDeep(defaultGenerateParams, overrideParams);
};

const createJsonFile = async (filePath, json) => {
  await fs.mkdir(dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, JSON.stringify(json, null, 2));
};

const generateTspec = async (
  generateParams = {},
) => {
  const params = await getGenerateTspecParams(generateParams);

  const {
    openapiSchemas, tspecSymbols,
  } = await getOpenapiSchemas(
    params.tsconfigPath || 'tsconfig.json',
    params.specPathGlobs,
    params.ignoreErrors,
  );

  const paths = getOpenapiPaths(openapiSchemas, tspecSymbols);
  const schemas = getOpenapiSchemasOnly(openapiSchemas, tspecSymbols);

  const openapi = {
    info: {
      title: _optionalChain([params, 'access', _5 => _5.openapi, 'optionalAccess', _6 => _6.title]) || 'Tspec API',
      version: _optionalChain([params, 'access', _7 => _7.openapi, 'optionalAccess', _8 => _8.version]) || '0.0.1',
      description: _optionalChain([params, 'access', _9 => _9.openapi, 'optionalAccess', _10 => _10.description]) || '',
    },
    openapi: (params.specVersion === 3 && '3.0.3') || '3.0.3',
    paths,
    components: {
      schemas,
      securitySchemes: _optionalChain([params, 'access', _11 => _11.openapi, 'optionalAccess', _12 => _12.securityDefinitions]),
    },
    servers: _optionalChain([params, 'access', _13 => _13.openapi, 'optionalAccess', _14 => _14.servers]),
  };

  if (params.outputPath) {
    await createJsonFile(params.outputPath, openapi);
  }

  return openapi;
};

const initTspecServer = async (options) => {
  const { port = 7000, proxyHost, ...generateOptions } = options || {};
  const app = express();
  const openapiSpec = await generateTspec(generateOptions);
  app.use('/docs', swaggerUI.serve, swaggerUI.setup(openapiSpec));
  if (proxyHost) {
    app.use('/', createProxyMiddleware({
      target: proxyHost,
      changeOrigin: true,
      logLevel: 'warn',
    }));
  }
  app.listen(port, () => {
    // eslint-disable-next-line no-console
    console.log(`Tspec API server is running on http://localhost:${port}/docs`);
    if (proxyHost) {
      // eslint-disable-next-line no-console
      console.log(`Tspec API server is proxying to ${proxyHost}`);
    }
  });
};

const TspecDocsMiddleware = async (
  generateOptions,
) => {
  const openapiSpec = await generateTspec(generateOptions);
  return [...swaggerUI.serve, swaggerUI.setup(openapiSpec)];
};

export { DEBUG as D, TspecDocsMiddleware as T, createJsonFile as c, defaultGenerateParams as d, generateTspec as g, initTspecServer as i };
